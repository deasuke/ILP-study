\documentclass[a4j,dvipdfmx]{jsarticle}
\usepackage{wrapfig}
\usepackage[dvips]{graphicx}
\usepackage{listings,jvlisting}
\usepackage{amssymb}
\newcommand{\fixed}[1]{{\ttfamily #1}}
\usepackage{forest}

\begin{document}

\section{プログラミングの種類について}
ILPにおいては、論理型プログラミングという、皆さんが普段扱ってこなかった種類のプログラミングを扱います。
このプログラミングの種類というか「やり方」の事をプログラミングパラダイムと呼んでいます。
各プログラミングパラダイムとそれに属するプログラミング言語の関係は図\ref{fig:programming_paradigms}
のようになっています。

皆さんが普段使っているPythonは命令型と呼ばれるパラダイムに属しますが、例えばtoolzなどのライブラリを
用いて関数型のプログラミングをすることも可能ですし、C++のboostライブラリでも同様のことが可能です。
図\ref{fig:programming_paradigms}は、その言語が最も得意とする方法ということで捉えて下さい。

ちなみに、磯邉さんの論文ではPrologというプログラミング言語を扱います。

\begin{figure}[htbp]
\centering
\begin{forest}
  for tree={grow'=0, l sep=3em, s sep=0.5em, anchor=west, child anchor=west, edge path={\noexpand\path[\forestoption{edge}] (!u.parent anchor) -- +(50pt,0) |- (.child anchor)\forestoption{edge label};}, tier/.wrap pgfmath arg={tier #1}{level()}}
  [プログラミング
    [命令型プログラミング
      [C]
      [Java]
      [Python]
      [...]
    ]
    [宣言型プログラミング
      [関数型プログラミング
        [Haskell]
        [Erlang]
        [Clojure]
        [...]
      ]
      [論理型プログラミング
        [Prolog]
        [Datalog]
        [...]
      ]
    ]
  ]
\end{forest}
\caption{プログラミングパラダイムとプログラミング言語の例}
\label{fig:programming_paradigms}
\end{figure}

\subsection{命令型と宣言型}
命令型プログラミングとは皆さんが普段使っているPythonやC, C++などで普段書いている方法です。
これらのプログラミング言語では、行うべき処理を順番に記述していきます。
処理を分岐させるif文や、処理を繰替えすためにforやwhileなどを利用して、
処理の流れを自分でコントロールします。

一方宣言型プログラミングにおいては、定義を記述していきます。
これには、関数の定義を記述していく方法と、論理の定義を記述していく方法の二通りに分かれます。

\subsection{関数型プログラミング}
関数型プログラミングの代表言語はLISPです。LISPでは関数を書くときに{\fixed f(x,y)}
の代わりに{\fixed (f x y)}のように書きます。このように書くことで関数呼出がリストの形となり、
プログラムを全部リストと見做すことが出来ます。そうすることでプログラムをデータとして扱うことが簡単になり、
プログラムを扱うプログラミング(メタプログラミングと言います -- 
後でやりますがILPはメタプログラミングの一種です)がやりやすくなります。

関数型プログラミングにおいて条件分岐は定義の場合分けです。{\fixed (if condition clause-a clause-b)}
という「関数」(厳密にはこれは関数ではなく特殊形式と言います)を考えて{\fixed if}が呼ばれると、
{\fixed condition}の値が真か偽かによって{\fixed clause-a}または{\fixed clause-b}を{\fixed if}「関数」
の結果と定義する訳です。
LISPにおいては、関数呼出はその引数をすべて評価(計算)してからその関数が計算されますが、
{\fixed if}「関数」においては使わなかったほうの{\fixed clause}は計算されません。こういうものは
厳密には「特殊形式」と呼びます。

関数型プログラミングにおいてくり返し処理は、再帰呼び出しで実現されます。
関数がコンピュータ内でどう実現されているかを知っている皆さんなら、
再帰呼出をくり返すとスタックが溢れるのではないかと心配されるかも知れません。
しかし、その心配は不要です。末尾における再帰呼出では、
スタックを消費せずに実行するように最適化することが可能です。これを末尾再帰の最適化と言います。

重要な特殊形式をあと1つ紹介します。{\fixed (defun name argument-list result)}は関数{\fixed name}
を定義します。関数の引数リストは{\fixed argument-list}で、その計算が{\fixed result}のリストで表わされます。
図\ref{fig:fibonacci}は階乗を計算する例です。二項演算や比較も関数の形式で書きます。

\begin{figure}[htbp]
\centering
\begin{lstlisting}[language=Lisp]
(defun factorial (n)
  (if (<= n 1)
      1
      (* n (factorial (- n 1)))))
\end{lstlisting}
\caption{LISPによる階乗計算の例}
\label{fig:fibonacci}
\end{figure}

\subsection{論理型プログラミング}
論理型プログラミングでは、問題を解決するための「ルール」を作り、それを元に答えを見つけます。

例えば、ある動物が「鳥」であるかどうかを判断するルールを作るとしましょう。そのルールは次のようになるかもしれません：

\begin{enumerate}
\item その動物が羽を持っているか？
\item その動物が飛べるか？
\end{enumerate}

これらのルールを元に、与えられた動物が「鳥」であるかどうかを判断します。もし、その動物がこれらのルールに当てはまるなら、その動物は「鳥」であるとは答えます。

\subsubsection{Prolog}

この例をProlog言語で見ていきます。まず、Prologに「事実(fact)」を入力します。
例えば図\ref{fig:fact}のように書きます。
\begin{figure}[htbp]
\centering
\begin{tabular}{l}
{\fixed 　持っている(スズメ, 羽). } \\
{\fixed 　飛べる(スズメ). }
\end{tabular}
\caption{Prologによる「事実」の入力例}
\label{fig:fact}
\end{figure}

これは、「スズメは羽を持っている」と「スズメは飛べる」という事実をPrologに教えています。
関数のような見た目をしていますが関数ではありませんので値を計算するという概念はありません。
次に、「ルール」を作ります。これは、ある事実が成り立つための条件です。例えば、
「鳥」になるためのルールは次のようになります：

\begin{figure}[htbp]
\centering
\begin{tabular}{l}
{\fixed 　鳥(X) :- 持っている(X, 羽), 飛べる(X). } 
\end{tabular}
\caption{Prologによる「ルール」の入力例}
\label{fig:rule}
\end{figure}

これは、「Xが羽を持っていて、Xが飛べるなら、Xは鳥である」というルールを表しています。
XはPrologにおける変数でアルファベットの大文字で開始することになっています。
これら、事実やルールのことを述語(predicate)と言います。
述語は文章で記述された命題を立式したものと言えます。文章題から方程式を立てるようなイメージです。
これらの事実とルールを元に、Prologは次のような質問に答えることができます：

\begin{figure}[htbp]
\centering
\begin{tabular}{l}
{\fixed 　?- 鳥(スズメ). } 
\end{tabular}
\caption{Prologによる「質問」の入力例}
\label{fig:query}
\end{figure}

Prologは事実とルールを見て、この質問に「Yes」と答えます。このことを推論(reasoning)と呼びます。
機械学習で推論と言えばinferenceなので日本語で「推論」と言う場合はどの意味なのかを確認する必要があります。

\subsubsection{閉世界仮説}
では、ペンギンに関する事実を入力してみましょう。
\begin{figure}[htbp]
\centering
\begin{tabular}{l}
{\fixed 　持っている(ペンギン, 羽). } 
\end{tabular}
\caption{Prologによる「事実」の入力例2}
\label{fig:fact2}
\end{figure}
ペンギンが飛べるかどうかについて書かれていませんね。世の中の命題では、真と証明できる命題、
偽と証明できる命題、真とも偽とも証明できる命題、の3通りがあると思いますが、Prologにおいては、
(少なくとも標準的には)真と証明できないものは偽と仮定します。このように仮定することを閉世界仮説と呼びます。
Prologに否定の述語を扱えるようにすることで閉世界仮説を不要するという研究もあるようです。

ここでは、ペンギンは飛べるという「事実」はないことから、閉世界仮説によりペンギンは飛べないことになります。そして先程と同様に{\fixed 　?- 鳥(ペンギン). } と聞くと「No」と答えます。世の中の事実とは異なりますが、
プログラムに入力した鳥の判定ルールからするとペンギンは鳥とは言えないので論理としては正しくなります。
世の中の事実とは異なるのは「ルール」が不完全だからです。

\subsubsection{単一化}
Prolog処理系(インタープリタ)がプログラム(事実とルール)と質問から推論(reasoning)を行なうためには、
質問とマッチする事実やルールを探します。事実とマッチすれば証明は成功して質問はYesとなります。
ルールとのマッチではルールの{\fixed :-}より左側と質問をマッチさせます。マッチしたら、
ルールの右側すべてを新な質問と見做してそれがすべてYesのときのみ、
このルールの右側が真であることが証明され、このルールの右側がYesとなります。

このマッチのことを単一化(unification)と言います。

「{\fixed 　?- 鳥(スズメ). } 」の質問の例では、「{\fixed 　鳥(スズメ)}」
と単一化できる事実やルールを探します。事実の中にはマッチするものはなく、ルールの中には
「 {\fixed　鳥(X) :- 持っている(X, 羽), 飛べる(X). } 」
 の右側とマッチできます。
「{\fixed 鳥(スズメ)}」と「{\fixed 鳥(X)}」が一致するには変数Xはスズメである必要があります。
そこでPrologはこのマッチの際にXにスズメを代入し、左側を順に質問します。

すなわち「{\fixed 　?- 持っている(スズメ, 羽).}」および、「{\fixed 　?-  飛べる(スズメ).}」を質問します。
これらは事実とマッチするのでどちらも答はYesとなり、このルール自体もYesとなって、証明が成功します。

もう少し複雑な単一化の例を見てみます。
「{\fixed 持っている(スズメ, X)}」と「{\fixed 持っている(Y, 羽).}」を単一化したいとします。
この場合、X=羽根、Y=スズメとすれば一致します。このように単一化は双方向に代入することが可能です。

\subsubsection{バックトラック}
鳥の例は一端忘れて次のPrologのプログラムを考えてみます。
このプログラムでは、山田氏は一郎君と二郎君という息子がおり、鈴木氏には、はると君とみなと君という
息子が居るとします。また同一の親をもつ場合に兄弟である、というルールがあるとします。

\begin{figure}[htbp]
\centering
\begin{tabular}{l}
{\fixed 　親子(山田氏, 一郎君). } \\
{\fixed 　親子(山田氏, 二郎君). } \\
{\fixed 　親子(鈴木氏, はると君). } \\
{\fixed 　親子(鈴木氏, みなと君). } \\
{\fixed 　兄弟(X, Y):-親子(Z, X), 親子(Z, Y). } \\
\end{tabular}
\caption{Prologによるプログラム例}
\label{fig:program}
\end{figure}

ここで「{\fixed 　?- 兄弟(X, みなと君). } 」という質問を投げてみます。
これは「Xに何を代入すれば、{\fixed　兄弟(X, みなと君).　}は真になりますか」という質問です。
普通の言葉では「みなと君の兄弟は誰ですか？」という意味の質問になるでしょう。
鳥の例のときの質問とは異なり、質問に変数が入っています。この場合、
変数に何かを代入することで真であれば代入結果とともにYes.が、
何を代入しても真であることが言えなければNo.が返ってきます。

ここでは、まず「兄弟(X, みなと君)」と単一化できるものを探します。すると、
「{\fixed 　兄弟(X, Y):-親子(Z, X), 親子(Z, Y). }」というルールが見付かりますが、
このルールでのXは質問のXとは異なる変数ですので名前をX1に付け替えましょう。
「{\fixed 　兄弟(X1, Y):-親子(Z, X1), 親子(Z, Y). }」として「X=X1, Y=みなと君」として単一化できます。
すると、新たな質問「親子(Z,X)」と「親子(Z,みなと君)」が出来ます。まずは質問「親子(Z,X)」を処理します。
これと単一化できるものはまず「親子(山田氏, 一郎君)」です。このとき「Z=山田氏、X=一郎君」となるので、
次の質問は「親子(山田氏, みなと君)」となりこれと単一化できるものはありません。よって失敗します。
すると前の質問「親子(Z,X)」に戻って他の単一化出来るものを探します。
戻るときにはその過程での代入は無かったことになります。
この動作をバックトラック(backtrack)と言います。

次の候補は「親子(山田氏, 二郎君)」ですが、これも同様に失敗してまたバックトラックし、
次の候補「親子(鈴木氏, はると君)」をみつけます。このときは「Z=鈴木氏、X=はると君」となるので、
次の質問は「親子(鈴木氏, みなと君)」となり、これは同一の事実と単一化できます。
よってこのルールの証明は成功し、Yes(X=みなと君)という結果が得られます。

ここでユーザが他の解を要求すると、Prologはこの結果を一端失敗とみなし、バックトラックします。
そして次の候補「親子(鈴木氏, はると君)」をみつけ、同様に成功し、Yes(X=はると君)という結果を得ます。
これは直感と反していますが、このプログラムで定義したルールでは、「兄弟(はると君, はると君)」
は正しくなってしまいますね。
もし、異なる(X, Y)という組み込みの述語があれば、最後の兄弟のルールを

{\fixed 　兄弟(X, Y):-親子(Z, X), 親子(Z, Y), 異なる(X, Y). } \\

とすると良いかもしれません。

\end{document}
